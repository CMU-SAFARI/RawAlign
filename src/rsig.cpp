#include "rsig.h"
#include "kvec.h"
#include <math.h>
#include <sys/stat.h>
#include <dirent.h>

void ri_seq_to_sig(const char *str, int len, const float* pore_vals, const int k, const int strand, uint32_t* s_len, float* s_values){

	int i, j, l, pos, n = 0;
	// uint64_t shift1 = 2 * (k - 1);
	uint64_t mask = (1ULL<<2*k) - 1, kmer = 0;
	double mean = 0, std_dev = 0, sum = 0, sum2 = 0, curval = 0;

	for (i = l = j = n = 0; i < len; ++i) {
		if(strand) pos = len - i -1;
		else pos = i;
		int c = seq_nt4_table[(uint8_t)str[pos]];
		if (c < 4) { // not an ambiguous base
			if(!strand) kmer = (kmer << 2 | c) & mask;    // forward k-mer
			// else kmer = (kmer >> 2) | (3ULL^c) << shift1; // reverse k-mer
			//TODO: this is currently based on the ordering in the original ordering in the sigmap implementation. Change later to above
			else kmer = ((kmer << 2) | (3ULL^c)) & mask; // reverse k-mer
		}else
      		kmer = (kmer << 2) & mask; //TODO: This is not the best approach. We are basically inserting 00 (A?) to kmer whenever c >= 4. Mask it instead

		if(i+1 < k) continue;

		curval = pore_vals[kmer];
		s_values[j++] = curval;
		sum += curval;
		sum2 += curval*curval;
	}

	mean = sum/j;
	std_dev = sqrt(sum2/j - (mean)*(mean));

	for(i = 0; i < j; ++i)
		s_values[i] = (s_values[i]-mean)/std_dev;

	*s_len = j;
}

ri_sig_file_t *ri_sig_open(const char *fn)
{
	ri_sig_file_t *fp;

	hdf5_tools::File* fast5_file = new hdf5_tools::File();
	fast5_file->open(std::string(fn));
	// gzFile f;
	// f = fn && strcmp(fn, "-")? gzopen(fn, "r") : gzdopen(0, "r");
	if (!fast5_file->is_open()) return 0;

	fp = (ri_sig_file_t*)calloc(1, sizeof(ri_sig_file_t));
	fp->fp = fast5_file;

	bool is_single = false;
	std::vector<std::string> fast5_file_groups = fast5_file->list_group("/");
	fp->num_read = fast5_file_groups.size();
	fp->ch_path = (char**)calloc(fp->num_read, sizeof(char*));
	fp->raw_path = (char**)calloc(fp->num_read, sizeof(char*));

	for (std::string &group : fast5_file_groups) {
		if (group == "Raw") {
			is_single = true;
			break;
		}
	}

	std::string raw_path;
	std::string ch_path;
	int i = 0;

	if (is_single) {
		ch_path = "/UniqueGlobalKey/channel_id";
		for (std::string &read : fast5_file->list_group("/Raw/Reads")) {
			raw_path = "/Raw/Reads/" + read;
			if(i == fp->num_read){
				fprintf(stdout, "ERROR: More reads than previously predicted (%d). Stopped reading the reads here.\n", fp->num_read);
				break;
			}
			fp->ch_path[i] = strdup(ch_path.c_str());
			fp->raw_path[i++] = strdup(raw_path.c_str());
		}
	} else {
		for (std::string &read : fast5_file_groups) {
			raw_path = "/" + read + "/Raw";
			ch_path = "/" + read + "/channel_id";
			fp->ch_path[i] = strdup(ch_path.c_str());
			fp->raw_path[i++] = strdup(raw_path.c_str());
		}
	}

	fp->num_read = i;
	fp->cur_read = 0;
	return fp;
}

void ri_sig_close(ri_sig_file_t *fp)
{
	if(!fp) return;
	// gzclose(fp->fp);
	fp->fp->close();
	for(int i = 0; i < fp->num_read; ++i){
		if(fp->ch_path[i])free(fp->ch_path[i]);
		if(fp->raw_path[i])free(fp->raw_path[i]);
	}
	free(fp->ch_path);
	free(fp->raw_path);
	delete fp->fp;
	free(fp);
}

ri_sig_file_t *open_sig(const char *fn) //TODO: make this a part of the pipeline. Sequntially reading from many FAST5 files creates an overhead
{
	ri_sig_file_t *fp;
	fp = (ri_sig_file_t*)calloc(1,sizeof(ri_sig_file_t));
	if ((fp = ri_sig_open(fn)) == 0) {
		fprintf(stderr, "ERROR: failed to open file '%s': %s\n", fn, strerror(errno));
		ri_sig_close(fp);
		return 0;
	}
	return fp;
}

ri_sig_file_t **open_sigs(int n, const char **fn) //TODO: make this a part of the pipeline. Sequntially reading from many FAST5 files creates an overhead
{
	ri_sig_file_t **fp;
	int i, j;
	fp = (ri_sig_file_t**)calloc(n, sizeof(ri_sig_file_t*));
	for (i = 0; i < n; ++i) {
		if ((fp[i] = ri_sig_open(fn[i])) == 0) {
			fprintf(stderr, "ERROR: failed to open file '%s': %s\n", fn[i], strerror(errno));
			for (j = 0; j < i; ++j) ri_sig_close(fp[j]);
			free(fp);
			return 0;
		}
	}
	return fp;
}

//Check if the input const char* A is a directory
//Generated by GitHub Copilot
int is_dir(const char *A)
{
	struct stat st;
	if (stat(A, &st) == -1) return 0;
	return S_ISDIR(st.st_mode);
}

//Recursively find all files that ends with "fast5" under input directory const char *A
//Generated by GitHub Copilot
void find_fast5(const char *A, ri_char_v *fnames)
{
	if (!is_dir(A)) {
		//TODO: Add slow5 here later
		if (strstr(A, ".fast5")) {
			char** cur_fname;
			kv_pushp(char*, 0, *fnames, &cur_fname);
			(*cur_fname) = strdup(A);
		}
		return;
	}

	DIR *dir;
	struct dirent *ent;
	if ((dir = opendir(A)) != NULL) {
		while ((ent = readdir(dir)) != NULL) {
			char *tmp = (char*)malloc(strlen(A) + strlen(ent->d_name) + 2);
			sprintf(tmp, "%s/%s", A, ent->d_name);
			if (is_dir(tmp)) {
				if (strcmp(ent->d_name, ".") && strcmp(ent->d_name, ".."))
					find_fast5(tmp, fnames);
			} else {
				if (strstr(ent->d_name, ".fast5")) {
					char** cur_fname;
					kv_pushp(char*, 0, *fnames, &cur_fname);
					(*cur_fname) = strdup(tmp);
				}
			}
			free(tmp);
		}
		closedir(dir);
	}
}

void ri_read_sig(ri_sig_file_t* fp, ri_sig_t* s){

	assert(fp->cur_read < fp->num_read);

	s->name = 0;
	for (auto a : fp->fp->get_attr_map(fp->raw_path[fp->cur_read])) {
		if (a.first == "read_id") {
			s->name = strdup(a.second.c_str());
		}
	}

	assert(s->name);

	// float digitisation = 0, range = 0, offset = 0;
	for (auto a : fp->fp->get_attr_map(fp->ch_path[fp->cur_read])) {
		if (a.first == "channel_number") {
		// channel_idx = atoi(a.second.c_str()) - 1;
		} else if (a.first == "digitisation") {
			s->dig = atof(a.second.c_str());
		} else if (a.first == "range") {
			s->ran = atof(a.second.c_str());
		} else if (a.first == "offset") {
			s->offset = atof(a.second.c_str());
		}
	}

	std::string sig_path = std::string(fp->raw_path[fp->cur_read]) + "/Signal";
	std::vector<float> discretized_sig;
	fp->fp->read(sig_path, discretized_sig);
	// convert to pA
	uint32_t l_sig = 0;
	float scale = s->ran/s->dig;
	for (size_t i = 0; i < discretized_sig.size(); i++) {
		float original_sig = (discretized_sig[i] + s->offset) * scale;
		if (original_sig > 30 && original_sig < 200) {
			discretized_sig[l_sig] = original_sig;
			++l_sig;
		}
	}

	s->sig = (float*)calloc(l_sig, sizeof(float));
	s->l_sig = l_sig;
	std::copy(discretized_sig.begin(), discretized_sig.begin() + l_sig, s->sig);
	fp->cur_read++;
}